/// \file
/// \date 2013-01-05
/// \author Xavier Michelon
///
/// \brief Implementation of game board class


#include "stdafx.h"
#include "GameEngine.h"
#include "Constants.h"


using namespace std;


//**********************************************************************************************************************
/// \return The only allowed instance of the class
//**********************************************************************************************************************
GameEngine& GameEngine::instance()
{
   static GameEngine board;
   return board;
}

//**********************************************************************************************************************
//
//**********************************************************************************************************************
GameEngine::GameEngine()
   : seed_(0)
{
   this->reset();
}


//**********************************************************************************************************************
// 
//**********************************************************************************************************************
GameEngine::~GameEngine()
{

}


//**********************************************************************************************************************
/// \param[in] seed The seed for the new game
//**********************************************************************************************************************
void GameEngine::newGame(quint32 seed)
{
   seed_ = seed;
   qsrand(seed_);
   this->reset();
}


//**********************************************************************************************************************
// 
//**********************************************************************************************************************
void GameEngine::newGame()
{
   // we do not want seed to be sequential so we also randomize it. as qrand() return a 16 bit numbers we concatenate
   // two values to get a 32 bit pseudo random value.
   qsrand(quint32(QDateTime::currentMSecsSinceEpoch()));
   this->newGame(quint32(qrand()) | (quint32(qrand()) << 16));
}


//**********************************************************************************************************************
// 
//**********************************************************************************************************************
void GameEngine::restartGame()
{
   ///< We reinitialize the random generator to the same seed, so what have the same game as before
   qsrand(seed_); 
   this->reset();
}


//**********************************************************************************************************************
// 
//**********************************************************************************************************************
void GameEngine::reset()
{
   turnsLeft_ = kTurnCount;
   gameBoard_.reset(seed_);
   isGameFinished_ = false;
   emit gameStarted();
}


//**********************************************************************************************************************
/// \param[in] color The color to play
//**********************************************************************************************************************
void GameEngine::playColor(EColor color)
{
   if (isGameFinished_) return;
   gameBoard_.spreadColor(color);
   --turnsLeft_;
   emit turnPlayed();
   this->checkForGameEnd();
}


//**********************************************************************************************************************
/// \return the number of turns left in the game
//**********************************************************************************************************************
qint32 GameEngine::getTurnsLeft() const
{
   return turnsLeft_;
}


//**********************************************************************************************************************
// 
//**********************************************************************************************************************
void GameEngine::checkForGameEnd()
{
   if (gameBoard_.gameIsWon())
   {
      isGameFinished_ = true;
      emit gameWon();
      return;
   }
   if (0 == turnsLeft_)
   {
      isGameFinished_ = true;
      emit gameLost();
   }
}


//**********************************************************************************************************************
/// \return The seed of the game
//**********************************************************************************************************************
quint32 GameEngine::getSeed() const
{
   return seed_;
}


//**********************************************************************************************************************
/// \return A constant reference to the game board
//**********************************************************************************************************************
GameBoard const& GameEngine::getGameBoard() const
{
   return gameBoard_;
}

